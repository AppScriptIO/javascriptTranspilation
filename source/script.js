"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));


const path = require('path'),
filesystem = require('fs'),
assert = require('assert'),
moduleSystem = require('module'),
EventEmitter = require('events'),
babelRegister = require(`@babel/register`),
{ addHook: addRequireHook } = require('pirates');



const targetProjectCallerPath = module.parent.parent.filename;


function getCompilerConfig(configKey) {
  return require(`./compilerConfiguration/${configKey}`);
}


function getBabelConfig(babelConfigFilename, { configType = 'json' } = {}) {
  const jsonConfig = require(`./compilerConfiguration/${babelConfigFilename}`);
  switch (configType) {
    case 'functionApi':
      return api => {
        api.cache.forever();
        return jsonConfig.babelConfig;
      };
      break;
    case 'json':
    default:
      return jsonConfig.babelConfig;
      break;}

  return;
}


module.exports.getBabelConfig = getBabelConfig;
module.exports.getCompilerConfig = getCompilerConfig;
const { addModuleResolutionPathMultiple } = require(`@dependency/addModuleResolutionPath`),
{ filesystemTranspiledOutput } = require('./additionalRequireHook.js'),
defaultRequireHookConfig = require('./compilerConfiguration/requireHookConfig.js'),
{ isPreservedSymlinkFlag } = require('./utility/isPreservedSymlinkFlag.js');




class Compiler {
  constructor({ babelTransformConfig, babelRegisterConfig, callerPath } = {}) {
    if (!babelRegisterConfig) babelRegisterConfig = defaultRequireHookConfig();
    if (!babelTransformConfig) {
      assert(callerPath, '• callerPath should be passed in case babel configuration was not provided');
      this.setTargetProject({ nestedProjectPath: [callerPath] });
      babelTransformConfig = this.targetProjectConfig.configuration.transpilation.babelConfig;
    }
    this.callerPath = callerPath;
    this.babelTransformConfig = babelTransformConfig;
    this.babelRegisterConfig = babelRegisterConfig;
  }
  requireHook({
    restrictToTargetProject = true } =
  {}) {
    function requireHook({ babelTransformConfig, babelRegisterConfig }) {


      babelRegister(Object.assign({}, babelTransformConfig, babelRegisterConfig));

    }
    if (restrictToTargetProject) {
      assert(this.callerPath, '• callerPath should be passed in order to lookup for project configuration.');
      this.setTargetProject({ nestedProjectPath: [this.callerPath] });
      const targetProjectFilesRegex = new RegExp(`^((?!${this.targetProjectConfig.rootPath}).)*$`);
      this.babelRegisterConfig.ignore.push(targetProjectFilesRegex);
    }
    let revertHook = requireHook({ babelTransformConfig: this.babelTransformConfig, babelRegisterConfig: this.babelRegisterConfig });
    Compiler.trackRegisteredHook();
    this.trackLoadedFile();
    return {
      revertHook: revertHook };

  }
  trackLoadedFile() {
    this.loadedFiles = this.loadedFiles || [];
    let ignoreFilenamePattern = this.babelRegisterConfig.ignore;
    let eventEmitter = new EventEmitter();
    addRequireHook(
    (code, filename) => {
      eventEmitter.emit('fileLoaded', { filename, code });
      return code;
    },
    {
      exts: this.babelRegisterConfig.extensions,
      ignoreNodeModules: false,
      matcher: filename => ignoreFilenamePattern.some(regex => filename.match(regex)) ? false : true });


    eventEmitter.on('fileLoaded', fileObject => this.loadedFiles.push((0, _objectSpread2.default)({}, fileObject)));
    return eventEmitter;
  }
  outputTranspilation() {
    this.setPrimaryTargetProject();

    return filesystemTranspiledOutput({
      babelConfig: this.babelTransformConfig,
      extension: this.babelRegisterConfig.extensions,
      ignoreFilenamePattern: this.babelRegisterConfig.ignore,
      shouldTransform: false,
      targetProjectConfig: this.primaryTargetProjectConfig });

  }
  setTargetProject({ nestedProjectPath = [] }) {
    if (this.targetProjectConfig) return;
    const { findTargetProjectRoot } = require('@dependency/configurationManagement');
    this.targetProjectConfig = findTargetProjectRoot({ nestedProjectPath });
  }

  setPrimaryTargetProject({ nestedProjectPath = [process.cwd(), module.parent.filename] } = {}) {
    if (this.primaryTargetProjectConfig) return;
    const { findTargetProjectRoot } = require('@dependency/configurationManagement');
    this.primaryTargetProjectConfig = findTargetProjectRoot({ nestedProjectPath });
  }}



Compiler.registeredHook = [];
Compiler.trackRegisteredHook = function () {
  Compiler.registeredHook.push(targetProjectCallerPath);
};


(function () {
  const babelModulesPath = path.dirname(path.dirname(path.dirname(require.resolve('@babel/core/package.json'))));
  addModuleResolutionPathMultiple({ pathArray: [babelModulesPath] });
})();




Object.assign(module.exports, { Compiler });
if (isPreservedSymlinkFlag())
throw new Error(
'• Using `preserve symlink` node runtime flag will cause infinite circular dependency, where each will load the module with different accumulative path when symlinking node_modules to each other.');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NvdXJjZS9zY3JpcHQuanMiXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJmaWxlc3lzdGVtIiwiYXNzZXJ0IiwibW9kdWxlU3lzdGVtIiwiRXZlbnRFbWl0dGVyIiwiYmFiZWxSZWdpc3RlciIsImFkZEhvb2siLCJhZGRSZXF1aXJlSG9vayIsInRhcmdldFByb2plY3RDYWxsZXJQYXRoIiwibW9kdWxlIiwicGFyZW50IiwiZmlsZW5hbWUiLCJnZXRDb21waWxlckNvbmZpZyIsImNvbmZpZ0tleSIsImdldEJhYmVsQ29uZmlnIiwiYmFiZWxDb25maWdGaWxlbmFtZSIsImNvbmZpZ1R5cGUiLCJqc29uQ29uZmlnIiwiYXBpIiwiY2FjaGUiLCJmb3JldmVyIiwiYmFiZWxDb25maWciLCJleHBvcnRzIiwiYWRkTW9kdWxlUmVzb2x1dGlvblBhdGhNdWx0aXBsZSIsImZpbGVzeXN0ZW1UcmFuc3BpbGVkT3V0cHV0IiwiZGVmYXVsdFJlcXVpcmVIb29rQ29uZmlnIiwiaXNQcmVzZXJ2ZWRTeW1saW5rRmxhZyIsIkNvbXBpbGVyIiwiY29uc3RydWN0b3IiLCJiYWJlbFRyYW5zZm9ybUNvbmZpZyIsImJhYmVsUmVnaXN0ZXJDb25maWciLCJjYWxsZXJQYXRoIiwic2V0VGFyZ2V0UHJvamVjdCIsIm5lc3RlZFByb2plY3RQYXRoIiwidGFyZ2V0UHJvamVjdENvbmZpZyIsImNvbmZpZ3VyYXRpb24iLCJ0cmFuc3BpbGF0aW9uIiwicmVxdWlyZUhvb2siLCJyZXN0cmljdFRvVGFyZ2V0UHJvamVjdCIsIk9iamVjdCIsImFzc2lnbiIsInRhcmdldFByb2plY3RGaWxlc1JlZ2V4IiwiUmVnRXhwIiwicm9vdFBhdGgiLCJpZ25vcmUiLCJwdXNoIiwicmV2ZXJ0SG9vayIsInRyYWNrUmVnaXN0ZXJlZEhvb2siLCJ0cmFja0xvYWRlZEZpbGUiLCJsb2FkZWRGaWxlcyIsImlnbm9yZUZpbGVuYW1lUGF0dGVybiIsImV2ZW50RW1pdHRlciIsImNvZGUiLCJlbWl0IiwiZXh0cyIsImV4dGVuc2lvbnMiLCJpZ25vcmVOb2RlTW9kdWxlcyIsIm1hdGNoZXIiLCJzb21lIiwicmVnZXgiLCJtYXRjaCIsIm9uIiwiZmlsZU9iamVjdCIsIm91dHB1dFRyYW5zcGlsYXRpb24iLCJzZXRQcmltYXJ5VGFyZ2V0UHJvamVjdCIsImV4dGVuc2lvbiIsInNob3VsZFRyYW5zZm9ybSIsInByaW1hcnlUYXJnZXRQcm9qZWN0Q29uZmlnIiwiZmluZFRhcmdldFByb2plY3RSb290IiwicHJvY2VzcyIsImN3ZCIsInJlZ2lzdGVyZWRIb29rIiwiYmFiZWxNb2R1bGVzUGF0aCIsImRpcm5hbWUiLCJyZXNvbHZlIiwicGF0aEFycmF5IiwiRXJyb3IiXSwibWFwcGluZ3MiOiI7OztBQUdBLE1BQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLE1BQUQsQ0FBcEI7QUFDRUMsVUFBVSxHQUFHRCxPQUFPLENBQUMsSUFBRCxDQUR0QjtBQUVFRSxNQUFNLEdBQUdGLE9BQU8sQ0FBQyxRQUFELENBRmxCO0FBR0VHLFlBQVksR0FBR0gsT0FBTyxDQUFDLFFBQUQsQ0FIeEI7QUFJRUksWUFBWSxHQUFHSixPQUFPLENBQUMsUUFBRCxDQUp4QjtBQUtFSyxhQUFhLEdBQUdMLE9BQU8sQ0FBRSxpQkFBRixDQUx6QjtBQU1FLEVBQUVNLE9BQU8sRUFBRUMsY0FBWCxLQUE4QlAsT0FBTyxDQUFDLFNBQUQsQ0FOdkM7Ozs7QUFVQSxNQUFNUSx1QkFBdUIsR0FBR0MsTUFBTSxDQUFDQyxNQUFQLENBQWNBLE1BQWQsQ0FBcUJDLFFBQXJEOzs7QUFHQSxTQUFTQyxpQkFBVCxDQUEyQkMsU0FBM0IsRUFBc0M7QUFDcEMsU0FBT2IsT0FBTyxDQUFFLDJCQUEwQmEsU0FBVSxFQUF0QyxDQUFkO0FBQ0Q7OztBQUdELFNBQVNDLGNBQVQsQ0FBd0JDLG1CQUF4QixFQUE2QyxFQUFFQyxVQUFVLEdBQUcsTUFBZixLQUEwQixFQUF2RSxFQUEyRTtBQUN6RSxRQUFNQyxVQUFVLEdBQUdqQixPQUFPLENBQUUsMkJBQTBCZSxtQkFB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QUFGLEVBQTlCO0FBQ0EsSUFBSUQsc0JBQXNCLEVBQTFCO0FBQ0UsTUFBTSxJQUFJa0QsS0FBSjtBQUNKLG9NQURJLENBQU4iLCJzb3VyY2VzQ29udGVudCI6WyIvLyBiYWJlbCBKUyBDb21waWxlciAtIFRoaXMgZmlsZSBzaG91bGQgYmUgd3JpdHRlbiBpbiBuYXRpdmUgRVNcbi8vIC5iYWJlbHJjIGRvZXNuJ3QgaGF2ZSBhIHdheSB0byBzcGVjaWZ5IHBhdGguXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyksXG4gIGZpbGVzeXN0ZW0gPSByZXF1aXJlKCdmcycpLFxuICBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKSxcbiAgbW9kdWxlU3lzdGVtID0gcmVxdWlyZSgnbW9kdWxlJyksXG4gIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLFxuICBiYWJlbFJlZ2lzdGVyID0gcmVxdWlyZShgQGJhYmVsL3JlZ2lzdGVyYCksXG4gIHsgYWRkSG9vazogYWRkUmVxdWlyZUhvb2sgfSA9IHJlcXVpcmUoJ3BpcmF0ZXMnKVxuLy8gbGV0IGZpbmRUYXJnZXRQcm9qZWN0Um9vdCAvLyBwb3NzaWJsZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuXG4vLyBSZXF1aXJpbmcgbW9kdWxlJ3MgcGF0aC5cbmNvbnN0IHRhcmdldFByb2plY3RDYWxsZXJQYXRoID0gbW9kdWxlLnBhcmVudC5wYXJlbnQuZmlsZW5hbWUgLy8gZmlyc3QgcGFyZW50IG1vZHVsZSBpcyB0aGUgZW50cnlwb2ludCBgaW5kZXguanNgLCBzZWNvbmQgaXMgdGhlIG1vZHVsZSB0aGF0IGNhbGxzIHRoZSByZXF1aXJlIGhvb2suXG5cbi8vIENvbXBpbGVyIGNvbmZpZ3VyYXRpb24gaW5jbHVkZXMgYGJhYmVsIHRyYW5zZm9ybWAgb3B0aW9ucyAmIGBAYmFiZWwvcmVnaXN0ZXJgIGNvbmZpZ3VyYXRpb24uXG5mdW5jdGlvbiBnZXRDb21waWxlckNvbmZpZyhjb25maWdLZXkpIHtcbiAgcmV0dXJuIHJlcXVpcmUoYC4vY29tcGlsZXJDb25maWd1cmF0aW9uLyR7Y29uZmlnS2V5fWApIC8vIGxvYWQgY29uZmlndXJhdGlvbiBlcXVpdmFsZW50IHRvIC5iYWJlbHJjIG9wdGlvbnNcbn1cblxuLy8gZXhwb3J0IGJhYmVsIGNvbmZpZ3VyYXRpbyBzZXRzIGFzIHdlbGxcbmZ1bmN0aW9uIGdldEJhYmVsQ29uZmlnKGJhYmVsQ29uZmlnRmlsZW5hbWUsIHsgY29uZmlnVHlwZSA9ICdqc29uJyB9ID0ge30pIHtcbiAgY29uc3QganNvbkNvbmZpZyA9IHJlcXVpcmUoYC4vY29tcGlsZXJDb25maWd1cmF0aW9uLyR7YmFiZWxDb25maWdGaWxlbmFtZX1gKVxuICBzd2l0Y2ggKGNvbmZpZ1R5cGUpIHtcbiAgICBjYXNlICdmdW5jdGlvbkFwaSc6XG4gICAgICByZXR1cm4gYXBpID0+IHtcbiAgICAgICAgYXBpLmNhY2hlLmZvcmV2ZXIoKVxuICAgICAgICByZXR1cm4ganNvbkNvbmZpZy5iYWJlbENvbmZpZ1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdqc29uJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGpzb25Db25maWcuYmFiZWxDb25maWdcbiAgICAgIGJyZWFrXG4gIH1cbiAgcmV0dXJuXG59XG5cbi8vIEVhcmx5IGV4cG9ydCBvZiBuZWNlc3NhcnkgbW9kdWxlcyB0byBhbGxvdyBuZXN0ZWQgZGVwZW5kZW5jaWVzIG9yIGNpcmN1bGFyIGRlcGVuZGVuY2llcyB0byB1c2UgdGhlIGluZGVwZW5kZW50IGV4cG9ydHMuXG5tb2R1bGUuZXhwb3J0cy5nZXRCYWJlbENvbmZpZyA9IGdldEJhYmVsQ29uZmlnXG5tb2R1bGUuZXhwb3J0cy5nZXRDb21waWxlckNvbmZpZyA9IGdldENvbXBpbGVyQ29uZmlnXG5jb25zdCB7IGFkZE1vZHVsZVJlc29sdXRpb25QYXRoTXVsdGlwbGUgfSA9IHJlcXVpcmUoYEBkZXBlbmRlbmN5L2FkZE1vZHVsZVJlc29sdXRpb25QYXRoYCksXG4gIHsgZmlsZXN5c3RlbVRyYW5zcGlsZWRPdXRwdXQgfSA9IHJlcXVpcmUoJy4vYWRkaXRpb25hbFJlcXVpcmVIb29rLmpzJyksXG4gIGRlZmF1bHRSZXF1aXJlSG9va0NvbmZpZyA9IHJlcXVpcmUoJy4vY29tcGlsZXJDb25maWd1cmF0aW9uL3JlcXVpcmVIb29rQ29uZmlnLmpzJyksXG4gIHsgaXNQcmVzZXJ2ZWRTeW1saW5rRmxhZyB9ID0gcmVxdWlyZSgnLi91dGlsaXR5L2lzUHJlc2VydmVkU3ltbGlua0ZsYWcuanMnKVxuXG4vKipcbiAqIFVzZWQgdG8gaW5pdGlhbGl6ZSBub2RlanMgYXBwIHdpdGggdHJhbnNwaWxlZCBjb2RlIHVzaW5nIEJhYmVsLCB0aHJvdWdoIGFuIGVudHJ5cG9pbnQuanMgd2hpY2ggbG9hZHMgdGhlIGFwcC5qc1xuICovXG5jbGFzcyBDb21waWxlciB7XG4gIGNvbnN0cnVjdG9yKHsgYmFiZWxUcmFuc2Zvcm1Db25maWcsIGJhYmVsUmVnaXN0ZXJDb25maWcsIGNhbGxlclBhdGggfSA9IHt9KSB7XG4gICAgaWYgKCFiYWJlbFJlZ2lzdGVyQ29uZmlnKSBiYWJlbFJlZ2lzdGVyQ29uZmlnID0gZGVmYXVsdFJlcXVpcmVIb29rQ29uZmlnKClcbiAgICBpZiAoIWJhYmVsVHJhbnNmb3JtQ29uZmlnKSB7XG4gICAgICBhc3NlcnQoY2FsbGVyUGF0aCwgJ+KAoiBjYWxsZXJQYXRoIHNob3VsZCBiZSBwYXNzZWQgaW4gY2FzZSBiYWJlbCBjb25maWd1cmF0aW9uIHdhcyBub3QgcHJvdmlkZWQnKVxuICAgICAgdGhpcy5zZXRUYXJnZXRQcm9qZWN0KHsgbmVzdGVkUHJvamVjdFBhdGg6IFtjYWxsZXJQYXRoXSB9KVxuICAgICAgYmFiZWxUcmFuc2Zvcm1Db25maWcgPSB0aGlzLnRhcmdldFByb2plY3RDb25maWcuY29uZmlndXJhdGlvbi50cmFuc3BpbGF0aW9uLmJhYmVsQ29uZmlnXG4gICAgfVxuICAgIHRoaXMuY2FsbGVyUGF0aCA9IGNhbGxlclBhdGhcbiAgICB0aGlzLmJhYmVsVHJhbnNmb3JtQ29uZmlnID0gYmFiZWxUcmFuc2Zvcm1Db25maWdcbiAgICB0aGlzLmJhYmVsUmVnaXN0ZXJDb25maWcgPSBiYWJlbFJlZ2lzdGVyQ29uZmlnXG4gIH1cbiAgcmVxdWlyZUhvb2soe1xuICAgIHJlc3RyaWN0VG9UYXJnZXRQcm9qZWN0ID0gdHJ1ZSwgLy8gdGhpcyBvcHRpb24gd2hlbiBmYWxzZSBhbGxvd3MgY2lyY3VsYXIgZGVwZW5kZW5jeSBgY29uZmlndXJhdGlvbk1hbmFnZW1lbnRgIHRvIHVzZSB0cmFuc3BpbGF0aW9uLlxuICB9ID0ge30pIHtcbiAgICBmdW5jdGlvbiByZXF1aXJlSG9vayh7IGJhYmVsVHJhbnNmb3JtQ29uZmlnLCBiYWJlbFJlZ2lzdGVyQ29uZmlnIH0pIHtcbiAgICAgIC8vIGNvbnNvbGUuZ3JvdXAoYFxceDFiWzJtXFx4MWJbM23igKIgQmFiZWw6XFx4MWJbMG0gQ29tcGlsaW5nIGNvZGUgYXQgcnVudGltZS5gKVxuICAgICAgLy8gVGhlIHJlcXVpcmUgaG9vayB3aWxsIGJpbmQgaXRzZWxmIHRvIG5vZGUncyByZXF1aXJlIGFuZCBhdXRvbWF0aWNhbGx5IGNvbXBpbGUgZmlsZXMgb24gdGhlIGZseVxuICAgICAgYmFiZWxSZWdpc3RlcihPYmplY3QuYXNzaWduKHt9LCBiYWJlbFRyYW5zZm9ybUNvbmZpZywgYmFiZWxSZWdpc3RlckNvbmZpZykpIC8vIENvbXBpbGUgY29kZSBvbiBydW50aW1lLlxuICAgICAgLy8gY29uc29sZS5ncm91cEVuZCgpXG4gICAgfVxuICAgIGlmIChyZXN0cmljdFRvVGFyZ2V0UHJvamVjdCkge1xuICAgICAgYXNzZXJ0KHRoaXMuY2FsbGVyUGF0aCwgJ+KAoiBjYWxsZXJQYXRoIHNob3VsZCBiZSBwYXNzZWQgaW4gb3JkZXIgdG8gbG9va3VwIGZvciBwcm9qZWN0IGNvbmZpZ3VyYXRpb24uJylcbiAgICAgIHRoaXMuc2V0VGFyZ2V0UHJvamVjdCh7IG5lc3RlZFByb2plY3RQYXRoOiBbdGhpcy5jYWxsZXJQYXRoXSB9KVxuICAgICAgY29uc3QgdGFyZ2V0UHJvamVjdEZpbGVzUmVnZXggPSBuZXcgUmVnRXhwKGBeKCg/ISR7dGhpcy50YXJnZXRQcm9qZWN0Q29uZmlnLnJvb3RQYXRofSkuKSokYCkgLy8gbmVnYXRpb24gLSBwYXRocyB0aGF0IGRvbid0IGluY2x1ZGUgdGhlIHBhdGggaS5lLiBvdXRzaWRlIHRoZSBkaXJlY3RvcnkuXG4gICAgICB0aGlzLmJhYmVsUmVnaXN0ZXJDb25maWcuaWdub3JlLnB1c2godGFyZ2V0UHJvamVjdEZpbGVzUmVnZXgpIC8vIHRyYW5zcGlsZSBmaWxlcyB0aGF0IGFyZSBuZXN0ZWQgaW4gdGhlIHRhcmdldCBwcm9qZWN0IG9ubHkuXG4gICAgfVxuICAgIGxldCByZXZlcnRIb29rID0gcmVxdWlyZUhvb2soeyBiYWJlbFRyYW5zZm9ybUNvbmZpZzogdGhpcy5iYWJlbFRyYW5zZm9ybUNvbmZpZywgYmFiZWxSZWdpc3RlckNvbmZpZzogdGhpcy5iYWJlbFJlZ2lzdGVyQ29uZmlnIH0pXG4gICAgQ29tcGlsZXIudHJhY2tSZWdpc3RlcmVkSG9vaygpIC8vIGtlZXAgdHJhY2sgb2YgYWxsIHByb2plY3RzIHRoYXQgaW5pdGlhdGVkIGEgcmVxdWlyZSBob29rIHJlZ2lzdHJhdGlvbi5cbiAgICB0aGlzLnRyYWNrTG9hZGVkRmlsZSgpXG4gICAgcmV0dXJuIHtcbiAgICAgIHJldmVydEhvb2s6IHJldmVydEhvb2ssXG4gICAgfVxuICB9XG4gIHRyYWNrTG9hZGVkRmlsZSgpIHtcbiAgICB0aGlzLmxvYWRlZEZpbGVzID0gdGhpcy5sb2FkZWRGaWxlcyB8fCBbXVxuICAgIGxldCBpZ25vcmVGaWxlbmFtZVBhdHRlcm4gPSB0aGlzLmJhYmVsUmVnaXN0ZXJDb25maWcuaWdub3JlXG4gICAgbGV0IGV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKVxuICAgIGFkZFJlcXVpcmVIb29rKFxuICAgICAgKGNvZGUsIGZpbGVuYW1lKSA9PiB7XG4gICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdmaWxlTG9hZGVkJywgeyBmaWxlbmFtZSwgY29kZSB9KVxuICAgICAgICByZXR1cm4gY29kZSAvLyBwYXNzIHRvIG5leHQgcmVnaXN0ZXJlZCBob29rIHdpdGhvdXQgY2hhbmdlcy5cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGV4dHM6IHRoaXMuYmFiZWxSZWdpc3RlckNvbmZpZy5leHRlbnNpb25zLFxuICAgICAgICBpZ25vcmVOb2RlTW9kdWxlczogZmFsc2UsXG4gICAgICAgIG1hdGNoZXI6IGZpbGVuYW1lID0+IChpZ25vcmVGaWxlbmFtZVBhdHRlcm4uc29tZShyZWdleCA9PiBmaWxlbmFtZS5tYXRjaChyZWdleCkpID8gZmFsc2UgOiB0cnVlKSxcbiAgICAgIH0sXG4gICAgKVxuICAgIGV2ZW50RW1pdHRlci5vbignZmlsZUxvYWRlZCcsIGZpbGVPYmplY3QgPT4gdGhpcy5sb2FkZWRGaWxlcy5wdXNoKHsgLi4uZmlsZU9iamVjdCB9KSlcbiAgICByZXR1cm4gZXZlbnRFbWl0dGVyXG4gIH1cbiAgb3V0cHV0VHJhbnNwaWxhdGlvbigpIHtcbiAgICB0aGlzLnNldFByaW1hcnlUYXJnZXRQcm9qZWN0KClcbiAgICAvLyBvdXRwdXQgdHJhbnNwaWxhdGlvbiByZXN1bHQgaW50byBmaWxlc3lzdGVtIGZpbGVzXG4gICAgcmV0dXJuIGZpbGVzeXN0ZW1UcmFuc3BpbGVkT3V0cHV0KHtcbiAgICAgIGJhYmVsQ29uZmlnOiB0aGlzLmJhYmVsVHJhbnNmb3JtQ29uZmlnLFxuICAgICAgZXh0ZW5zaW9uOiB0aGlzLmJhYmVsUmVnaXN0ZXJDb25maWcuZXh0ZW5zaW9ucyxcbiAgICAgIGlnbm9yZUZpbGVuYW1lUGF0dGVybjogdGhpcy5iYWJlbFJlZ2lzdGVyQ29uZmlnLmlnbm9yZSxcbiAgICAgIHNob3VsZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgICB0YXJnZXRQcm9qZWN0Q29uZmlnOiB0aGlzLnByaW1hcnlUYXJnZXRQcm9qZWN0Q29uZmlnLFxuICAgIH0pXG4gIH1cbiAgc2V0VGFyZ2V0UHJvamVjdCh7IG5lc3RlZFByb2plY3RQYXRoID0gW10gfSkge1xuICAgIGlmICh0aGlzLnRhcmdldFByb2plY3RDb25maWcpIHJldHVyblxuICAgIGNvbnN0IHsgZmluZFRhcmdldFByb2plY3RSb290IH0gPSByZXF1aXJlKCdAZGVwZW5kZW5jeS9jb25maWd1cmF0aW9uTWFuYWdlbWVudCcpIC8vIHJlcXVpcmUgaGVyZSB0byBwcmV2ZW50IGN5Y2xpYyBkZXBlbmRlbmN5IHdpdGggdGhpcyBtb2R1bGUsIGFzIHRoZSBtb2R1bGUgbWF5IHVzZSBydW50aW1lIHRyYW5zcGlsYXRpb24gKGkuZS4gd2lsbCB1c2UgZXhwb3J0ZWQgZnVuY3Rpb25hbGl0eSBmcm9tIHRoaXMgbW9kdWxlKS5cbiAgICB0aGlzLnRhcmdldFByb2plY3RDb25maWcgPSBmaW5kVGFyZ2V0UHJvamVjdFJvb3QoeyBuZXN0ZWRQcm9qZWN0UGF0aCB9KVxuICB9XG4gIC8vIG1haW4gdGFyZ2V0IHByb2plY3QgdGhhdCBpbml0aWF0ZWQgdGhlIG5vZGUgcHJvY2VzcyBmcm9tIGNsaSBvciByZXF1aXJlIHRoZSBtb2R1bGUgYmVmb3JlIGJlaW5nIGNhY2hlZCwgaW4gY2FzZXMgd2hlcmUgbm9kZV9tb2R1bGVzIGFyZSBhbHNvIHRyYW5zcGlsZWQuXG4gIHNldFByaW1hcnlUYXJnZXRQcm9qZWN0KHsgbmVzdGVkUHJvamVjdFBhdGggPSBbcHJvY2Vzcy5jd2QoKSwgbW9kdWxlLnBhcmVudC5maWxlbmFtZSAvKiBUaGUgcGxhY2Ugd2hlcmUgdGhlIG1vZHVsZSB3YXMgcmVxdWlyZWQgZnJvbSAqL10gfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMucHJpbWFyeVRhcmdldFByb2plY3RDb25maWcpIHJldHVyblxuICAgIGNvbnN0IHsgZmluZFRhcmdldFByb2plY3RSb290IH0gPSByZXF1aXJlKCdAZGVwZW5kZW5jeS9jb25maWd1cmF0aW9uTWFuYWdlbWVudCcpIC8vIHJlcXVpcmUgaGVyZSB0byBwcmV2ZW50IGN5Y2xpYyBkZXBlbmRlbmN5IHdpdGggdGhpcyBtb2R1bGUsIGFzIHRoZSBtb2R1bGUgbWF5IHVzZSBydW50aW1lIHRyYW5zcGlsYXRpb24gKGkuZS4gd2lsbCB1c2UgZXhwb3J0ZWQgZnVuY3Rpb25hbGl0eSBmcm9tIHRoaXMgbW9kdWxlKS5cbiAgICB0aGlzLnByaW1hcnlUYXJnZXRQcm9qZWN0Q29uZmlnID0gZmluZFRhcmdldFByb2plY3RSb290KHsgbmVzdGVkUHJvamVjdFBhdGggfSlcbiAgfVxufVxuXG4vLyByZWdpc3RlciB0aGUgbW9kdWxlcyB0aGF0IHJlZ2lzdGVyZWQgYSByZXF1aXJlIGhvb2sgZm9yIGNvbXBpbGF0aW9uLlxuQ29tcGlsZXIucmVnaXN0ZXJlZEhvb2sgPSBbXSAvLyBpbml0aWFsaXplIHByb3BlcnR5LlxuQ29tcGlsZXIudHJhY2tSZWdpc3RlcmVkSG9vayA9IGZ1bmN0aW9uKCkge1xuICBDb21waWxlci5yZWdpc3RlcmVkSG9vay5wdXNoKHRhcmdldFByb2plY3RDYWxsZXJQYXRoKVxufVxuXG4vLyBpbml0aWFsaXplIC0gcmVnaXN0ZXIgTm9kZSBNb2R1bGUgUmVzb2x1dGlvbiBQYXRoXG47KGZ1bmN0aW9uKCkge1xuICBjb25zdCBiYWJlbE1vZHVsZXNQYXRoID0gcGF0aC5kaXJuYW1lKHBhdGguZGlybmFtZShwYXRoLmRpcm5hbWUocmVxdWlyZS5yZXNvbHZlKCdAYmFiZWwvY29yZS9wYWNrYWdlLmpzb24nKSkpKSAvLyBnZXQgdGhlIG5vZGVfbW9kdWxlcyBmb2xkZXIgd2hlcmUgQmFiZWwgcGx1Z2lucyBhcmUgaW5zdGFsbGVkLiBDb3VsZCBiZSBvd24gcGFja2FnZSByb290IG9yIHBhcmVudCBwYWNrYWdlcyByb290ICh3aGVuIHRoaXMgbW9kdWxlcyBpcyBpbnN0YWxsZWQgYXMgYSBwYWNha2dlKVxuICBhZGRNb2R1bGVSZXNvbHV0aW9uUGF0aE11bHRpcGxlKHsgcGF0aEFycmF5OiBbYmFiZWxNb2R1bGVzUGF0aF0gfSkgLy8gQWRkIGJhYmVsIG5vZGVfbW9kdWxlcyB0byBtb2R1bGUgcmVzb2x2aW5nIHBhdGhzXG59KSgpXG4vKipcbiAqIGV4cG9ydCBiZWZvcmUgaW1wb3J0aW5nIHBvc3NpYmxlIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAqIGV4cG9ydCBlY21hc2NyaXB0IHNwZWNpZmljYXRpb24gY29tcGxpZW50IG1vZHVsZXMgYWxsb3cgY2lyY3VsYXIgbW9kdWxlIGRlcGVuZGVuY3nYslxuICovXG5PYmplY3QuYXNzaWduKG1vZHVsZS5leHBvcnRzLCB7IENvbXBpbGVyIH0pXG5pZiAoaXNQcmVzZXJ2ZWRTeW1saW5rRmxhZygpKVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ+KAoiBVc2luZyBgcHJlc2VydmUgc3ltbGlua2Agbm9kZSBydW50aW1lIGZsYWcgd2lsbCBjYXVzZSBpbmZpbml0ZSBjaXJjdWxhciBkZXBlbmRlbmN5LCB3aGVyZSBlYWNoIHdpbGwgbG9hZCB0aGUgbW9kdWxlIHdpdGggZGlmZmVyZW50IGFjY3VtdWxhdGl2ZSBwYXRoIHdoZW4gc3ltbGlua2luZyBub2RlX21vZHVsZXMgdG8gZWFjaCBvdGhlci4nLFxuICApXG4vLyA7KHsgZmluZFRhcmdldFByb2plY3RSb290IH0gPSByZXF1aXJlKCdAZGVwZW5kZW5jeS9jb25maWd1cmF0aW9uTWFuYWdlbWVudCcpKSAvLyByZXF1aXJlIGhlcmUgdG8gcHJldmVudCBjeWNsaWMgZGVwZW5kZW5jeSB3aXRoIHRoaXMgbW9kdWxlLCBhcyB0aGUgbW9kdWxlIG1heSB1c2UgcnVudGltZSB0cmFuc3BpbGF0aW9uIChpLmUuIHdpbGwgdXNlIGV4cG9ydGVkIGZ1bmN0aW9uYWxpdHkgZnJvbSB0aGlzIG1vZHVsZSkuXG4iXX0=