"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {(0, _defineProperty2.default)(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}const path = require('path'),
filesystem = require('fs'),
assert = require('assert'),
EventEmitter = require('events'),
requireHook = require('./requireHook.js'),
{ defaultRequireHookConfig } = require('./getConfig.js'),
deepCloneJSNativeType = require('clone-deep'),
{ mergeNonexistentProperties } = require('@dependency/handleJSNativeDataStructure');




class Compiler extends EventEmitter {
  constructor({ babelConfig, callerPath } = {}) {
    super();
    Compiler.instance.push(this);

    this.config = babelConfig;
    this.callerPath = callerPath;









    this.loadedFiles = this.loadedFiles || [];

    this.initializeTransformConfiguration();
  }


  initializeTransformConfiguration() {


    this.config = deepCloneJSNativeType(this.config);
    assert(defaultRequireHookConfig.ignore, `• Must contain at least ignore property, as it is used in the Compiler instance and modified when needed.`);

    mergeNonexistentProperties(this.config, deepCloneJSNativeType(defaultRequireHookConfig));

    if (!this.config.plugins && !this.config.presets) {
      assert(
      this.targetProjectConfig.configuration.transpilation && this.targetProjectConfig.configuration.transpilation.babelConfig,
      `• Project configuration must have 'transpilation' & nested 'babelConfig' entries.`);

      this.setTargetProject();
      Object.assign(this.config, this.targetProjectConfig.configuration.transpilation.babelConfig);
    }
  }

  requireHook({ restrictToTargetProject = true } = {}) {
    if (restrictToTargetProject) {
      this.setTargetProject();

      const targetProjectFilesRegex = new RegExp(`^((?!${this.targetProjectConfig.rootPath}).)*$`);
      this.config.ignore.push(targetProjectFilesRegex);
    }


    this.on('fileLoaded', fileObject => this.loadedFiles.push(_objectSpread({}, fileObject)));


    let revertHook = requireHook.babelRegister({ babelConfig: this.config });


    requireHook.trackFile({
      emit: (code, filename) => this.emit('fileLoaded', { filename, code }),
      ignoreFilenamePattern: this.config.ignore,
      extension: this.config.extensions });



    this.setPrimaryTargetProject();
    requireHook.writeFileToDisk({
      extension: this.config.extensions,
      ignoreFilenamePattern: this.config.ignore,
      shouldTransform: false,
      targetProjectConfig: this.primaryTargetProjectConfig });


    return { revertHook };
  }


  setTargetProject() {
    if (this.targetProjectConfig) return;
    assert(this.callerPath, '• callerPath should be passed in case babel configuration was not provided');
    const { findTargetProjectRoot } = require('@dependency/configurationManagement');
    this.targetProjectConfig = findTargetProjectRoot({ nestedProjectPath: [this.callerPath] });
  }


  setPrimaryTargetProject({ nestedProjectPath = [process.cwd(), module.parent.filename] } = {}) {
    if (this.primaryTargetProjectConfig) return;
    const { findTargetProjectRoot } = require('@dependency/configurationManagement');
    this.primaryTargetProjectConfig = findTargetProjectRoot({ nestedProjectPath });
  }}



Compiler.instance = [];













Compiler.transpilationModulePath = path.join(__dirname, '..');

module.exports = {
  Compiler };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NvdXJjZS9Db21waWxlci5jbGFzcy5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsImZpbGVzeXN0ZW0iLCJhc3NlcnQiLCJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlSG9vayIsImRlZmF1bHRSZXF1aXJlSG9va0NvbmZpZyIsImRlZXBDbG9uZUpTTmF0aXZlVHlwZSIsIm1lcmdlTm9uZXhpc3RlbnRQcm9wZXJ0aWVzIiwiQ29tcGlsZXIiLCJjb25zdHJ1Y3RvciIsImJhYmVsQ29uZmlnIiwiY2FsbGVyUGF0aCIsImluc3RhbmNlIiwicHVzaCIsImNvbmZpZyIsImxvYWRlZEZpbGVzIiwiaW5pdGlhbGl6ZVRyYW5zZm9ybUNvbmZpZ3VyYXRpb24iLCJpZ25vcmUiLCJwbHVnaW5zIiwicHJlc2V0cyIsInRhcmdldFByb2plY3RDb25maWciLCJjb25maWd1cmF0aW9uIiwidHJhbnNwaWxhdGlvbiIsInNldFRhcmdldFByb2plY3QiLCJPYmplY3QiLCJhc3NpZ24iLCJyZXN0cmljdFRvVGFyZ2V0UHJvamVjdCIsInRhcmdldFByb2plY3RGaWxlc1JlZ2V4IiwiUmVnRXhwIiwicm9vdFBhdGgiLCJvbiIsImZpbGVPYmplY3QiLCJyZXZlcnRIb29rIiwiYmFiZWxSZWdpc3RlciIsInRyYWNrRmlsZSIsImVtaXQiLCJjb2RlIiwiZmlsZW5hbWUiLCJpZ25vcmVGaWxlbmFtZVBhdHRlcm4iLCJleHRlbnNpb24iLCJleHRlbnNpb25zIiwic2V0UHJpbWFyeVRhcmdldFByb2plY3QiLCJ3cml0ZUZpbGVUb0Rpc2siLCJzaG91bGRUcmFuc2Zvcm0iLCJwcmltYXJ5VGFyZ2V0UHJvamVjdENvbmZpZyIsImZpbmRUYXJnZXRQcm9qZWN0Um9vdCIsIm5lc3RlZFByb2plY3RQYXRoIiwicHJvY2VzcyIsImN3ZCIsIm1vZHVsZSIsInBhcmVudCIsInRyYW5zcGlsYXRpb25Nb2R1bGVQYXRoIiwiam9pbiIsIl9fZGlybmFtZSIsImV4cG9ydHMiXSwibWFwcGlu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QXBCOzs7Ozs7Ozs7Ozs7OztBQWNBSixRQUFRLENBQUMyQyx1QkFBVCxHQUFtQ3BELElBQUksQ0FBQ3FELElBQUwsQ0FBVUMsU0FBVixFQUFxQixJQUFyQixDQUFuQzs7QUFFQUosTUFBTSxDQUFDSyxPQUFQLEdBQWlCO0FBQ2Y5QyxFQUFBQSxRQURlLEVBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgZmlsZXN5c3RlbSA9IHJlcXVpcmUoJ2ZzJyksXG4gIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpLFxuICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKSxcbiAgcmVxdWlyZUhvb2sgPSByZXF1aXJlKCcuL3JlcXVpcmVIb29rLmpzJyksXG4gIHsgZGVmYXVsdFJlcXVpcmVIb29rQ29uZmlnIH0gPSByZXF1aXJlKCcuL2dldENvbmZpZy5qcycpLFxuICBkZWVwQ2xvbmVKU05hdGl2ZVR5cGUgPSByZXF1aXJlKCdjbG9uZS1kZWVwJyksXG4gIHsgbWVyZ2VOb25leGlzdGVudFByb3BlcnRpZXMgfSA9IHJlcXVpcmUoJ0BkZXBlbmRlbmN5L2hhbmRsZUpTTmF0aXZlRGF0YVN0cnVjdHVyZScpXG5cbi8qKlxuICogVXNlZCB0byBpbml0aWFsaXplIG5vZGVqcyBhcHAgd2l0aCB0cmFuc3BpbGVkIGNvZGUgdXNpbmcgQmFiZWwsIHRocm91Z2ggYW4gZW50cnlwb2ludC5qcyB3aGljaCBsb2FkcyB0aGUgYXBwLmpzIGFmdGVyIHJlZ2lzdGVyaW5nIHRoZSB0cmFuc3BpbGF0aW9uIHJlcXVpcmUgaG9va3MuXG4gKi9cbmNsYXNzIENvbXBpbGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoeyBiYWJlbENvbmZpZywgY2FsbGVyUGF0aCB9ID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgQ29tcGlsZXIuaW5zdGFuY2UucHVzaCh0aGlzKSAvLyB0cmFjayBpbnN0YW5jZXNcblxuICAgIHRoaXMuY29uZmlnID0gYmFiZWxDb25maWdcbiAgICB0aGlzLmNhbGxlclBhdGggPSBjYWxsZXJQYXRoXG5cbiAgICAvKiogVXNhZ2U6IFxuICAgICAgYGBgXG4gICAgICAgIHByb2Nlc3Mub24oJ2V4aXQnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coY29tcGlsZXIubG9hZGVkRmlsZXMubWFwKHZhbHVlID0+IHZhbHVlLmZpbGVuYW1lKSlcbiAgICAgICAgICBjb25zb2xlLmxvZyhjb21waWxlci5iYWJlbFJlZ2lzdGVyQ29uZmlnLmlnbm9yZSlcbiAgICAgICAgfSlcbiAgICAgIGBgYFxuICAgICAgKi9cbiAgICB0aGlzLmxvYWRlZEZpbGVzID0gdGhpcy5sb2FkZWRGaWxlcyB8fCBbXVxuXG4gICAgdGhpcy5pbml0aWFsaXplVHJhbnNmb3JtQ29uZmlndXJhdGlvbigpIC8vIHNldCBiYWJlbCBjb25maWcgdmFsdWVzXG4gIH1cblxuICAvLyBiYWJlbCBjb25maWd1cmF0aW9ucyAtIHBsdWdpbnMsIHByZXNldHMsIGlnbm9yZSwgZXh0ZW5zaW9ucywgZXRjLlxuICBpbml0aWFsaXplVHJhbnNmb3JtQ29uZmlndXJhdGlvbigpIHtcbiAgICAvLyBtYWtlIHN1cmUgdGhlIG9iamVjdCBwYXNzZWQgaXMgdW5pcXVlIChwcmV2ZW50IGNvbmZsaWN0cyBpbiBjYXNlIGNvbmZpZ3MgYXJlIHVzZWQgZnJvbSB0aGUgc2FtZSBtb2R1bGUgbXVsdGlwbGUgdGltZXMpXG4gICAgLy8gYXMgdGhlIHByb3BlcnRpZXMgb2YgdGhpcy5jb25maWcgY2FuIGJlIG1vZGlmaWVkIGJ5IHRoZSBpbnN0YW5jZSAoZS5nLiB0aGlzLmNvbmZpZy5pZ25vcmUpXG4gICAgdGhpcy5jb25maWcgPSBkZWVwQ2xvbmVKU05hdGl2ZVR5cGUodGhpcy5jb25maWcpXG4gICAgYXNzZXJ0KGRlZmF1bHRSZXF1aXJlSG9va0NvbmZpZy5pZ25vcmUsIGDigKIgTXVzdCBjb250YWluIGF0IGxlYXN0IGlnbm9yZSBwcm9wZXJ0eSwgYXMgaXQgaXMgdXNlZCBpbiB0aGUgQ29tcGlsZXIgaW5zdGFuY2UgYW5kIG1vZGlmaWVkIHdoZW4gbmVlZGVkLmApXG4gICAgLy8gbWVyZ2Ugb25seSBpZiBwcm9wZXJ0aWVzIGRvZXNuJ3QgZXhpc3RcbiAgICBtZXJnZU5vbmV4aXN0ZW50UHJvcGVydGllcyh0aGlzLmNvbmZpZywgZGVlcENsb25lSlNOYXRpdmVUeXBlKGRlZmF1bHRSZXF1aXJlSG9va0NvbmZpZykgLypjbG9uZSBkZWVwIG9iamVjdHMgdG8gcHJldmVudCBjb25mbGljdHMgYmV0d2VlbiBpbnN0YW5jZXMuKi8pXG5cbiAgICBpZiAoIXRoaXMuY29uZmlnLnBsdWdpbnMgJiYgIXRoaXMuY29uZmlnLnByZXNldHMpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdGhpcy50YXJnZXRQcm9qZWN0Q29uZmlnLmNvbmZpZ3VyYXRpb24udHJhbnNwaWxhdGlvbiAmJiB0aGlzLnRhcmdldFByb2plY3RDb25maWcuY29uZmlndXJhdGlvbi50cmFuc3BpbGF0aW9uLmJhYmVsQ29uZmlnLFxuICAgICAgICBg4oCiIFByb2plY3QgY29uZmlndXJhdGlvbiBtdXN0IGhhdmUgJ3RyYW5zcGlsYXRpb24nICYgbmVzdGVkICdiYWJlbENvbmZpZycgZW50cmllcy5gLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRUYXJnZXRQcm9qZWN0KClcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIHRoaXMudGFyZ2V0UHJvamVjdENvbmZpZy5jb25maWd1cmF0aW9uLnRyYW5zcGlsYXRpb24uYmFiZWxDb25maWcpXG4gICAgfVxuICB9XG5cbiAgcmVxdWlyZUhvb2soeyByZXN0cmljdFRvVGFyZ2V0UHJvamVjdCA9IHRydWUgLyogdGhpcyBvcHRpb24gd2hlbiBmYWxzZSBhbGxvd3MgY2lyY3VsYXIgZGVwZW5kZW5jeSBgY29uZmlndXJhdGlvbk1hbmFnZW1lbnRgIHRvIHVzZSB0cmFuc3BpbGF0aW9uLiAqLyB9ID0ge30pIHtcbiAgICBpZiAocmVzdHJpY3RUb1RhcmdldFByb2plY3QpIHtcbiAgICAgIHRoaXMuc2V0VGFyZ2V0UHJvamVjdCgpXG4gICAgICAvLyBiYWJlbCBjb25maWcgaWdub3JlIGdsb2JzIGFuZCByZWdleCB0byBtYXRjaCBmaWxlcyBhbmQgZmlsdGVyIHRoZSBmaWxlcyB0byB0cmFuc3BpbGVcbiAgICAgIGNvbnN0IHRhcmdldFByb2plY3RGaWxlc1JlZ2V4ID0gbmV3IFJlZ0V4cChgXigoPyEke3RoaXMudGFyZ2V0UHJvamVjdENvbmZpZy5yb290UGF0aH0pLikqJGApIC8vIG5lZ2F0aW9uIC0gcGF0aHMgdGhhdCBkb24ndCBpbmNsdWRlIHRoZSBwYXRoIGkuZS4gb3V0c2lkZSB0aGUgZGlyZWN0b3J5LlxuICAgICAgdGhpcy5jb25maWcuaWdub3JlLnB1c2godGFyZ2V0UHJvamVjdEZpbGVzUmVnZXgpIC8vIHRyYW5zcGlsZSBmaWxlcyB0aGF0IGFyZSBuZXN0ZWQgaW4gdGhlIHRhcmdldCBwcm9qZWN0IG9ubHkuXG4gICAgfVxuXG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMub24oJ2ZpbGVMb2FkZWQnLCBmaWxlT2JqZWN0ID0+IHRoaXMubG9hZGVkRmlsZXMucHVzaCh7IC4uLmZpbGVPYmplY3QgfSkpXG5cbiAgICAvLyB0aGlzLmNvbmZpZy5pZ25vcmUgPSBbL25vZGVfbW9kdWxlcy8sIC9eKCg/IVxcL2RcXC9jb2RlXFwvQXBwXFwvZ2F6aXRlbmdXZWJhcHBcXC9ub2RlX21vZHVsZXNcXC9AYXBwbGljYXRpb25cXC9nYXppdGVuZ1dlYmFwcC1jbGllbnRTaWRlKS4pKiQvXVxuICAgIGxldCByZXZlcnRIb29rID0gcmVxdWlyZUhvb2suYmFiZWxSZWdpc3Rlcih7IGJhYmVsQ29uZmlnOiB0aGlzLmNvbmZpZyB9KVxuXG4gICAgLy8gdHJhY2tpbmcgZmlsZXMgaXMgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBvbmx5LCB0aGUgYWN0dWFsIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb24gaGFwcGVucyBpbiBiYWJlbCBgcmVxdWlyZUhvb2tgLiBUaGUgdHJhY2tlciB0cmllcyB0byBtaW1pYyB0aGUgZ2xvYiBmaWxlIG1hdGNoaW5nIHVzaW5nIHRoZSBpZ25vcmUgb3B0aW9uIHBhc3NlZCBgYmFiZWxSZWdpc3RlckNvbmZpZy5pZ25vcmVgXG4gICAgcmVxdWlyZUhvb2sudHJhY2tGaWxlKHtcbiAgICAgIGVtaXQ6IChjb2RlLCBmaWxlbmFtZSkgPT4gdGhpcy5lbWl0KCdmaWxlTG9hZGVkJywgeyBmaWxlbmFtZSwgY29kZSB9KSxcbiAgICAgIGlnbm9yZUZpbGVuYW1lUGF0dGVybjogdGhpcy5jb25maWcuaWdub3JlLFxuICAgICAgZXh0ZW5zaW9uOiB0aGlzLmNvbmZpZy5leHRlbnNpb25zLFxuICAgIH0pXG5cbiAgICAvLyBvdXRwdXQgdHJhbnNwaWxhdGlvbiAtIG91dHB1dCB0cmFuc3BpbGF0aW9uIHJlc3VsdCBpbnRvIGZpbGVzeXN0ZW0gZmlsZXNcbiAgICB0aGlzLnNldFByaW1hcnlUYXJnZXRQcm9qZWN0KClcbiAgICByZXF1aXJlSG9vay53cml0ZUZpbGVUb0Rpc2soe1xuICAgICAgZXh0ZW5zaW9uOiB0aGlzLmNvbmZpZy5leHRlbnNpb25zLFxuICAgICAgaWdub3JlRmlsZW5hbWVQYXR0ZXJuOiB0aGlzLmNvbmZpZy5pZ25vcmUsXG4gICAgICBzaG91bGRUcmFuc2Zvcm06IGZhbHNlLFxuICAgICAgdGFyZ2V0UHJvamVjdENvbmZpZzogdGhpcy5wcmltYXJ5VGFyZ2V0UHJvamVjdENvbmZpZyxcbiAgICB9KVxuXG4gICAgcmV0dXJuIHsgcmV2ZXJ0SG9vayB9XG4gIH1cblxuICAvLyBsb29rdXAgdGhlIHByb2plY3QgdGhhdCBpbnN0YW50aWF0ZWQgYSBDb21waWxlciBpbnN0YW5jZS5cbiAgc2V0VGFyZ2V0UHJvamVjdCgpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQcm9qZWN0Q29uZmlnKSByZXR1cm5cbiAgICBhc3NlcnQodGhpcy5jYWxsZXJQYXRoLCAn4oCiIGNhbGxlclBhdGggc2hvdWxkIGJlIHBhc3NlZCBpbiBjYXNlIGJhYmVsIGNvbmZpZ3VyYXRpb24gd2FzIG5vdCBwcm92aWRlZCcpXG4gICAgY29uc3QgeyBmaW5kVGFyZ2V0UHJvamVjdFJvb3QgfSA9IHJlcXVpcmUoJ0BkZXBlbmRlbmN5L2NvbmZpZ3VyYXRpb25NYW5hZ2VtZW50JykgLy8gcmVxdWlyZSBoZXJlIHRvIHByZXZlbnQgY3ljbGljIGRlcGVuZGVuY3kgd2l0aCB0aGlzIG1vZHVsZSwgYXMgdGhlIG1vZHVsZSBtYXkgdXNlIHJ1bnRpbWUgdHJhbnNwaWxhdGlvbiAoaS5lLiB3aWxsIHVzZSBleHBvcnRlZCBmdW5jdGlvbmFsaXR5IGZyb20gdGhpcyBtb2R1bGUpLlxuICAgIHRoaXMudGFyZ2V0UHJvamVjdENvbmZpZyA9IGZpbmRUYXJnZXRQcm9qZWN0Um9vdCh7IG5lc3RlZFByb2plY3RQYXRoOiBbdGhpcy5jYWxsZXJQYXRoXSB9KVxuICB9XG5cbiAgLy8gbWFpbiB0YXJnZXQgcHJvamVjdCB0aGF0IGluaXRpYXRlZCB0aGUgbm9kZSBwcm9jZXNzIGZyb20gY2xpIG9yIHJlcXVpcmUgdGhlIG1vZHVsZSBiZWZvcmUgYmVpbmcgY2FjaGVkLCBpbiBjYXNlcyB3aGVyZSBub2RlX21vZHVsZXMgYXJlIGFsc28gdHJhbnNwaWxlZC5cbiAgc2V0UHJpbWFyeVRhcmdldFByb2plY3QoeyBuZXN0ZWRQcm9qZWN0UGF0aCA9IFtwcm9jZXNzLmN3ZCgpLCBtb2R1bGUucGFyZW50LmZpbGVuYW1lIC8qIFRoZSBwbGFjZSB3aGVyZSB0aGUgbW9kdWxlIHdhcyByZXF1aXJlZCBmcm9tICovXSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5wcmltYXJ5VGFyZ2V0UHJvamVjdENvbmZpZykgcmV0dXJuXG4gICAgY29uc3QgeyBmaW5kVGFyZ2V0UHJvamVjdFJvb3QgfSA9IHJlcXVpcmUoJ0BkZXBlbmRlbmN5L2NvbmZpZ3VyYXRpb25NYW5hZ2VtZW50JykgLy8gcmVxdWlyZSBoZXJlIHRvIHByZXZlbnQgY3ljbGljIGRlcGVuZGVuY3kgd2l0aCB0aGlzIG1vZHVsZSwgYXMgdGhlIG1vZHVsZSBtYXkgdXNlIHJ1bnRpbWUgdHJhbnNwaWxhdGlvbiAoaS5lLiB3aWxsIHVzZSBleHBvcnRlZCBmdW5jdGlvbmFsaXR5IGZyb20gdGhpcyBtb2R1bGUpLlxuICAgIHRoaXMucHJpbWFyeVRhcmdldFByb2plY3RDb25maWcgPSBmaW5kVGFyZ2V0UHJvamVjdFJvb3QoeyBuZXN0ZWRQcm9qZWN0UGF0aCB9KVxuICB9XG59XG5cbi8vIHRyYWNrIGluc3RhbmNlcyBpbiBjdXJyZW50IHByb2Nlc3NcbkNvbXBpbGVyLmluc3RhbmNlID0gW11cbi8vIC8vIGRlYnVnIGNyZWF0ZWQgaW5zdGFuY2VzIGluIGN1cnJlbnQgcHJvY2Vzc1xuLy8gcHJvY2Vzcy5vbignZXhpdCcsICgpID0+IHtcbi8vICAgZm9yIChsZXQgY29tcGlsZXIgb2YgQ29tcGlsZXIuaW5zdGFuY2UpIGNvbnNvbGUubG9nKGNvbXBpbGVyLmJhYmVsUmVnaXN0ZXJDb25maWcuaWdub3JlKVxuLy8gICBjb25zb2xlLmxvZyhDb21waWxlci5pbnN0YW5jZVswXS5iYWJlbFRyYW5zZm9ybUNvbmZpZy5pZ25vcmUgPT09IENvbXBpbGVyLmluc3RhbmNlWzFdLmJhYmVsVHJhbnNmb3JtQ29uZmlnLmlnbm9yZSlcbi8vIH0pXG5cbi8qIFRPRE86IHJlZ2lzdGVyIHRoZSBtb2R1bGVzIHRoYXQgcmVnaXN0ZXJlZCBhIHJlcXVpcmUgaG9vayBmb3IgY29tcGlsYXRpb24uIGtlZXAgdHJhY2sgb2YgYWxsIHByb2plY3RzIHRoYXQgaW5pdGlhdGVkIGEgcmVxdWlyZSBob29rIHJlZ2lzdHJhdGlvbi4gXG4gICAgKEhvdyB0byBmaW5kIG91dCB0aGUgbW9kdWxlIHBhdGggdGhhdCBpbml0aWF0ZXMgYSBDb21waWxlciBpbnN0YW5jZSB3aXRob3V0IHBhc3NpbmcgaW4gJ19fZGlybmFtZScgPyBcbiAgICAgIGkuZS4gaGFja2lzaCB3YXkgdG8gZmluZCBmdW5jdGlvbiBjYWxsZXIgaW4gRUNNQXNjcmlwdClcbiAgICBTZWVtcyBsaWtlIGEgd29ya2Fyb3VuZCAtIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMjI3NDg5L2hvdy1jYW4tb25lLWdldC10aGUtZmlsZS1wYXRoLW9mLXRoZS1jYWxsZXItZnVuY3Rpb24taW4tbm9kZS1qcyAqL1xuLy8gQ29tcGlsZXIucmVnaXN0ZXJlZEhvb2sgPSBbXSAvLyBpbml0aWFsaXplIHByb3BlcnR5LlxuLy8gQ29tcGlsZXIudHJhY2tSZWdpc3RlcmVkSG9vayA9ICgpID0+IENvbXBpbGVyLnJlZ2lzdGVyZWRIb29rLnB1c2goLypQcm9qZWN0IHRoYXQgY3JlYXRlZCBhIG5ldyBpbnN0YW5jZSBvZiBDb21waWxlciovKVxuXG5Db21waWxlci50cmFuc3BpbGF0aW9uTW9kdWxlUGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLicpIC8vIGlmIG11bHRpcGxlIG1vZHVsZXMgYXJlIGluc3RhbGxlZCBpbiBkaWZmZXJlbnQgcGFja2FnZXMgcmF0aGVyIHRoYW4gdXNpbmcgdGhlIHNhbWUgbW9kdWxlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ29tcGlsZXIsXG59XG4iXX0=